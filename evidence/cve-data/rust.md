# Rust — Weaknesses, Failures, and Criticisms: Evidence File

```yaml
role: researcher
language: "Rust"
agent: "claude-agent"
date: "2026-02-26"
focus: "documented problems, criticisms, and failures only"
```

---

## 1. Async Ecosystem Fragmentation

### The Colored Function Problem

Rust's `async`/`await` model introduces what is commonly called the "colored function problem": any function that calls an `async` function must itself be `async`, causing the async-ness to propagate virally through a codebase. Bob Nystrom's foundational essay on function coloring describes this as asynchronous functions—"red" functions—being callable only from other red functions.

The Rust community has debated whether Rust's async is "truly" colored. The consensus from multiple 2021–2024 blog posts is: yes, it is.

- "Rust async functions are colored, by both the original definition and in practice" — [morestina.net](https://morestina.net/1686/rust-async-is-colored), May 2021
- "Rust does indeed have colored functions" — [The Coded Message](https://www.thecodedmessage.com/posts/async-colors/)
- "Rust also falls into the category of 'colored functions'" — [SeaQL blog](https://www.sea-ql.org/blog/2024-05-20-async-rainbow-bridge/), May 2024

The `bitbashing.io` article "Async Rust Is A Bad Language" (2023) goes further: async's viral nature means "any function that calls an `async` function must itself be `async`", and this cascades to lifetime challenges "everywhere, all the time." The article also notes that sharing state across async tasks typically requires either moving data (often impossible without cloning) or using `'static` references, unlike `thread::scope` for threads, which has lifetime-bounding mechanisms. [Source: https://bitbashing.io/async-rust.html]

### No Standard Async Runtime

Rust deliberately ships with no async runtime in the standard library. From the official async book: "There is no asynchronous runtime in the standard library, and none are officially recommended." [https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html]

An open GitHub issue (#2916 on rust-lang/rfcs, "async runtime into std") documents community pressure to change this. The official response from team member Jacob Pratt redirected the discussion, and the consensus position is that a full production runtime will never be in `std` because "almost all production uses of async/await will still want to use their own executor tailored to the specific application's needs." [https://github.com/rust-lang/rfcs/issues/2916]

### Multiple Incompatible Runtimes

The primary runtimes are Tokio, async-std (now deprecated), and smol. These are not compatible:

- Tokio uses the `mio` reactor and defines its own `AsyncRead`/`AsyncWrite` traits.
- async-std and smol rely on the `async-executor` crate and use `futures`-crate traits.
- Libraries written for one runtime's traits do not work with the other's without compatibility shims.

The corrode.dev analysis ("The State of Async Rust: Runtimes") reports: "If you don't want tokio, it's a fight against every dependency." Matthias Endler, the author, writes: "my sentiments regarding the current state of its ecosystem are now somewhat ambivalent." He recommends using async "only when you really need it." Popular crates like `reqwest` simply mandate Tokio as a required runtime. [Source: https://corrode.dev/blog/async/]

**async-std has been deprecated** (discontinued as of 2025). The maintainers recommend migrating to smol. The deprecation notice was not visible on docs.rs, creating a situation where developers stumbling onto the crate thought it was still a valid choice. A discussion on the Rust Internals forum (August 2025) identified this as a systemic gap: "It's a bit of a gap that there does not seem to be a good way to flag a crate as deprecated." [https://internals.rust-lang.org/t/async-std-deprecation/23395]

The result is a "winner-takes-all" ecosystem dominated by Tokio: Tokio is used at runtime in 20,768 crates (of which 5,245 depend on it optionally). [Tech Champion: https://tech-champion.com/general/the-one-true-runtime-friction-in-async-rust-development/]

### Documented Pain Points from Official Sources

Niko Matsakis (a former Rust Language Team co-lead), writing "What I'd like to see for Async Rust in 2024" (January 2024), explicitly catalogued unresolved async pain points:

- **Send bound problem:** Prevents generic traits from working uniformly across executor types (e.g., blocks the `tower::Service` trait from reaching 1.0 stability).
- **Lack of async closures:** Users cannot convert synchronous functions to async using closures, requiring convoluted workarounds.
- **No async Drop:** The `Drop` trait cannot be async, creating "a major pain point for users" for resource cleanup.
- **Runtime interop:** "Switching runtimes or writing code that is generic over what runtime it uses is very hard to impossible, made even worse by the fact that runtimes often don't play nice together."
- **`FutureUnordered` and `select` rough edges:** These utilities "easily lead to deadlock" when managing nested tasks.

The author notes these issues "require improvements in the language, standard library, and the ecosystem." [Source: https://smallcultfollowing.com/babysteps/blog/2024/01/03/async-rust-2024/]

The 2024 State of Rust Survey (n=7,310) documented that "struggles with async programming (an all-time favourite)" was among the top open-ended feedback categories for productivity limitations. [https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results/]

---

## 2. Compile Time Problem

### Measurements: Kobzol Blog Post, June 2025

Jakub Beranek ("kobzol"), a member of the Rust compiler performance working group, published "Why doesn't Rust care more about compiler performance?" on June 9, 2025. [https://kobzol.github.io/rust/rustc/2025/06/09/why-doesnt-rust-care-more-about-compiler-performance.html]

**Specific measurements from the post:**
- The `hyperqueue` project: clean build time dropped from 26.1 seconds (rustc 1.61.0, May 2022) to 14.7 seconds (rustc 1.87.0, May 2025) — a 1.77× speedup over 3 years.
- Despite this, the author acknowledges this is still "not fast enough" for many developers seeking order-of-magnitude improvements.

**Root causes identified:**
- "Rust has a complex type system, borrow checking, monomorphization, proc macros and build scripts, large translation units, machine code generation and a 'rebuild the world from source' compilation model" that has historically prioritized runtime performance over compilation performance.
- Most "low-hanging fruit" has been picked; improvements now require difficult trade-offs.
- LLVM backend (responsible for code generation and optimization) consumes the majority of time in clean builds for binary artifacts.
- The linker becomes the dominant bottleneck during incremental rebuilds.
- Monomorphization generates a separate copy of generic code for each concrete type instantiation, producing large LLVM IR.

**Why the project hasn't prioritized it more:**
- "Rust is not a company" — the project relies on volunteers whose interests vary.
- 99 supported targets require stability maintenance across all of them.
- Major refactorings (e.g., the trait solver reimplementation) require "several years" of sustained effort.

### C++ vs. Rust Compile Time: Quadratic Scaling

A January 2023 analysis by the Shape of Code blog compared compile times for equivalent C++ and Rust codebases (9.3K + 9.5K LOC) by duplicating the largest file 1×, 8×, 16×, and 32× times:

| File copies | C++ factor | Rust factor |
|-------------|------------|-------------|
| 1           | 1.03×      | 0.98×       |
| 8           | 1.25×      | 1.52×       |
| 16          | 1.57×      | 2.52×       |
| 32          | 2.45×      | 6.90×       |

The finding: "The size factor for Rust is growing quadratically, while it is much closer to linear for C++." The regression model explained 92% of variance across 360 C++ and 1,066 Rust runs on Linux. [Source: https://shape-of-code.com/2023/01/29/a-comparison-of-c-and-rust-compiler-performance/]

### Developer Survey Data

**Rust Compiler Performance Survey 2025** (official, Rust Blog, September 2025, n=3,700+):
- Average satisfaction with compile times: **6/10** (most chose 7/10)
- **55% of respondents** must wait more than 10 seconds for incremental rebuilds after code changes
- **~25% of CI users** report build performance as a major blocker
- **45% of developers who stopped using Rust** cited long compile times as a reason for leaving
- **42% haven't tried any build optimization mechanisms** (build profiling, different linkers, etc.)
[Source: https://blog.rust-lang.org/2025/09/10/rust-compiler-performance-survey-2025-results/]

**2023 Annual Rust Survey** (Rust Blog, February 2024, n=~9,000+):
- Compile time identified as "one of the most important areas that should be improved"
- **43% worried about Rust becoming too complex** (up 5pp from 2022)
- **45% wanted compile time improvements** (vs. 57% wanting runtime performance improvements and 68% wanting compiler bug fixes)
[Source: https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results/]

**2024 State of Rust Survey** (Rust Blog, February 2025, n=7,310):
- "Slow compilation was at the top of the list, as it seems to be a perennial concern of Rust users."
- Also cited: "Rust tooling being slow or resource intensive (rust-analyzer and rustfmt)"
[Source: https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results/]

---

## 3. Governance Issues

### The 2021 Moderation Team Resignation

In November 2021, the entire Rust moderation team resigned simultaneously. The resignation was filed as a pull request to the rust-lang/team repository: [https://github.com/rust-lang/team/pull/671]

The stated reason, as documented in The Register, The New Stack, and Slashdot:

> "The Core Team are answerable only to themselves, which is a property unique to them in contrast to all other Rust teams."

The moderation team stated: "As a result of such structural unaccountability, we have been unable to enforce the Rust Code of Conduct to the standards the community expected of us."

They recommended: (1) establishing a consensus process for Core Team oversight, (2) having non-Core Team members select the replacement moderation team, (3) professional mediation resources.

**Note on retraction:** On December 8, 2021, the team partially retracted the "be skeptical of Core" wording, calling it poor judgment, while maintaining the structural accountability critique.

Sources:
- https://www.theregister.com/2021/11/23/rust_moderation_team_quits/
- https://thenewstack.io/rust-mod-team-resigns-in-protest-of-unaccountable-core-team/
- https://developers.slashdot.org/story/21/11/27/0123211/rusts-moderation-team-resigns-to-protest-unaccountable-core-team

### The 2022 Core Team Departures

In February 2022, three members of the Rust Core Team resigned. The Register reported on this as further structural instability: "Trio of Rust Core Team members hit the road." [https://www.theregister.com/2022/02/01/rust_core_team_departures/]

### The 2023 RustConf Keynote Incident

On May 26, 2023, JeanHeyd Meneide ("ThePhD") announced they would not speak at RustConf 2023. They had been invited to give a keynote on compile-time reflection ("A Possible Future for Compile-Time Programming"), then told two weeks later it would be downgraded to a regular talk. [https://thephd.dev/i-am-no-longer-speaking-at-rustconf-2023]

Meneide described: "shadowy decisions that are non-transparent to normal contributors." The decision came through RustConf organizers rather than the Rust Project leadership who had invited them.

The Rust project issued a public apology acknowledging the decision was "not right" and the invitation downgrade was "insulting." The official blog post (May 29, 2023) stated:

> "We failed you JeanHeyd."

The root cause identified was that "leadership chat" — the interim governance body created after the 2021 moderation team resignation — "lacked clear rules and processes for decision making and communication." Multiple individuals in leadership "exercised poor judgment and poor communication" and voluntarily stepped back from top-level governance roles.

DevClass reported on the wider fallout: "More Rust ructions as project team confesses failure of 'leadership chat'." [https://devclass.com/2023/05/31/more-rust-ructions-as-project-team-confesses-failure-of-leadership-chat/]

Sources:
- https://blog.rust-lang.org/2023/05/29/RustConf/
- https://lwn.net/Articles/933198/

### RFC-3392: The Leadership Council "Constitution"

RFC-3392 established the current Leadership Council as a replacement for the Core Team, essentially constituting a governance reform in response to the above crises. Rust Project Reveals New 'Constitution' in Wake of Crisis — Slashdot headline, March 2023. [https://developers.slashdot.org/story/23/03/05/018235/rust-project-reveals-new-constitution-in-wake-of-crisis]

**Criticism of the RFC process for RFC-3392 itself:**
- "The RFC was developed almost entirely in private, which contradicted the principles of the Rust project and those espoused in the RFC itself, particularly since governance work should not have been done in private."
- Commenters noted "It took way too long," with suspicions of obstruction.
[Source: LWN.net analysis: https://lwn.net/Articles/935354/]

### RFC Process Dysfunction (General)

Nicholas Cameron, a former Rust project member, published "We need to talk about RFCs" (ncameron.org):
- "they are a lot of effort to write," "a lot of effort for teams to manage"
- "54 currently open RFCs from 2020 or older (i.e., more than a year old)" (as of the post's writing)
- Discussion threads "become overwhelming" with chronological-only ordering
- Teams delay participation until Final Comment Period, creating "pattern of initial high-volume, but low-value discussion"
- Stabilization decisions "happen far less visible" than RFC discussions
[Source: https://www.ncameron.org/blog/the-problem-with-rfcs/]

---

## 4. Unsafe Code and Soundness Issues

### Rust Foundation "Unsafe Rust in the Wild" Report (2024)

**Study scope:** Analysis of crates.io as of May 2024, ~127,000 crates with significant code (out of ~145,000 total).

**Key findings:**
- **19.11%** of crates (24,362) use the `unsafe` keyword directly
- **34.35%** make direct function calls into another crate that uses `unsafe`
- The majority of `unsafe` uses are FFI calls to C/C++ libraries (e.g., the Windows API crate is the largest single user of `unsafe` blocks)

[Source: https://rustfoundation.org/media/unsafe-rust-in-the-wild-notes-on-the-current-state-of-unsafe-rust/]

The critical implication: the 34.35% figure means over one-third of crates transitively depend on `unsafe` code even when they appear to be "safe Rust." This means a crate's safety guarantees are only as strong as the `unsafe` invariants maintained by its dependency tree.

### RUDRA: Automated Soundness Bug Detection (SOSP '21)

Yechan Bae et al., "Rudra: Finding Memory Safety Bugs in Rust at the Ecosystem Scale," SOSP 2021. [Distinguished Artifact Award]

**Key findings:**
- RUDRA analyzed 43,000 packages (the full crates.io registry as of the study date) in 6.5 hours
- Found **264 previously unknown memory safety bugs** in the ecosystem
- These led to **76 CVEs** and **112 RustSec advisories** filed
- Represented **51.6% of all memory safety bugs reported to RustSec since 2016**
- Two bugs were found in the Rust standard library itself; one in the official `futures` library; one in the Rust compiler

Bug categories detected by RUDRA:
1. **Panic safety** — unsafe code that becomes unsound when a panic unwinds
2. **Higher-order safety invariants** — violating safety contracts passed through generic/closure parameters
3. **Propagating Send/Sync in generic types** — incorrectly implementing `Send`/`Sync` for types containing non-`Send`/non-`Sync` data

[Sources: https://dl.acm.org/doi/10.1145/3477132.3483570 and https://gts3.org/assets/papers/2021/bae:rudra.pdf]

### Notable Specific Soundness Bugs in Major Crates

**Tokio (RUSTSEC-2023-0005):** `tokio::io::ReadHalf<T>::unsplit` was unsound for `T: !Unpin` types. The method violated the `Pin` contract by allowing the inner type to be moved out of a shared `Arc` after a `Pin<&mut T>` reference had been created, leading to potential use-after-free. Affected all tokio versions since 0.1.12; patched in 1.18.5, 1.20.4, 1.24.2. [https://rustsec.org/advisories/RUSTSEC-2023-0005.html]

**`ouroboros` (RUSTSEC-2023-0042):** The entire `ouroboros` self-referential struct crate was declared unsound. [https://rustsec.org/advisories/RUSTSEC-2023-0042.html]

**`self_cell` (RUSTSEC-2023-0070):** Insufficient covariance check made self_cell unsound in versions prior to 1.0.2. [https://rustsec.org/advisories/RUSTSEC-2023-0070]

**`lexical-core` (RUSTSEC-2023-0086):** Multiple soundness issues. [https://rustsec.org/advisories/RUSTSEC-2023-0086.html]

**`fast-float` (RUSTSEC-2024-0379):** Multiple soundness issues reported October 2024. [https://rustsec.org/advisories/RUSTSEC-2024-0379.html]

**RustSec "unsound" keyword total:** The RustSec advisory database lists **15 advisories** explicitly tagged with the "unsound" keyword as of early 2026, spanning from 2019 to 2026. [https://rustsec.org/keywords/unsound.html]

**Rust standard library soundness issues:** Per SandCell (arxiv 2509.24032), "In the last 3 years, 57 soundness issues have been filed in the Rust standard library and 20 CVEs have been reported. Of these soundness issues, 28% of them were discovered in 2024." [https://arxiv.org/html/2509.24032v1]

**GitHub I-unsound label:** The rust-lang/rust repository maintains an "I-unsound" label for open issues representing known soundness holes in the compiler and standard library. [https://github.com/rust-lang/rust/labels/I-unsound]

### The "Safety is Non-Local" Problem

A 2023 blog post "The rabbit hole of unsafe Rust bugs" (notgull.net) describes a real soundness bug found in `portable-atomic-util`'s `Arc` implementation:

```rust
// The buggy line — no `unsafe` keyword here
let new_ptr = strict::map_addr(ptr, |addr| addr + mem::size_of::<Header>());
```

The calculation failed to account for alignment padding. When `ConcurrentQueue` changed from 8-byte to 128-byte alignment (for cache-line optimization), compiler-inserted padding between fields invalidated the calculated pointer — but only when the unsafe dereference occurred in a completely different crate.

The author's conclusion: "safety is non-local — validating unsafe code requires understanding all dependencies and how safe abstractions preserve invariants they assume." [https://notgull.net/cautionary-unsafe-tale/]

---

## 5. Lifetime Annotation Complexity

### Borrow Checker False Positives

The borrow checker rejects valid programs in documented categories. A blog post "The borrowchecker is what I like the least about Rust" (viralinstruction.com) categorizes the failures:

**Partial field borrowing** — The borrow checker does not understand that two method calls access disjoint fields of a struct:

```rust
struct Point { x: f64, y: f64 }
impl Point {
    fn x_mut(&mut self) -> &mut f64 { &mut self.x }
    fn y_mut(&mut self) -> &mut f64 { &mut self.y }
}
fn main() {
    let mut point = Point { x: 1.0, y: 2.0 };
    let x_ref = point.x_mut();
    let y_ref = point.y_mut(); // ERROR: two mutable borrows via method calls
}
```

This compiles fine if done as `let x_ref = &mut point.x; let y_ref = &mut point.y;` (direct field access), but not through method calls, because the borrow checker cannot reason through function boundaries about which fields are accessed.

**Cross-function reasoning failure:**

```rust
struct Collection { counter: u32, items: Vec<u32> }
impl Collection {
    fn increment_counter(&mut self) { self.counter += 1; }
    pub fn count_items(&mut self) {
        for _ in &self.items { self.increment_counter(); } // ERROR
    }
}
```

The borrow checker cannot verify that `increment_counter` does not touch `self.items`, so it rejects code that is demonstrably safe.

**Branch-aware lifetime failure (NLL limitation):** The famous "entry API" problem — a function that conditionally inserts into a `HashMap` and returns a reference compiles only in Polonius (the next-generation borrow checker), not in the current stable borrow checker, even though the control flow clearly shows the two references are never live simultaneously.

The author's verdict: "My experience has been that borrowchecker problems are _mostly_ just bullshit – invented problems without real grounding." [Source: https://viralinstruction.com/posts/borrowchecker/]

### Polonius: The Replacement That Took Over 8 Years

Polonius is the next-generation borrow checker, first announced circa 2018, which would fix the NLL limitation for conditionally returned references and several other false positives.

As of 2025:
- Polonius has been in development for over 7 years (a EuroRust 2024 talk was titled "The First Six Years in the Development of Polonius"). [https://eurorust.eu/2024/talks/the-first-six-years-in-the-development-of-polonius/]
- It requires opt-in via `-Zpolonius` on nightly; not stable.
- The 2025h2 Rust Project Goals state the objective is to make a "stabilizable version" of the Polonius "alpha" algorithm that "needs more work to be properly usable on nightly." [https://rust-lang.github.io/rust-project-goals/2025h2/polonius.html]
- The original datalog-based implementation had unacceptable performance and was replaced with a native rustc implementation.

### Higher-Ranked Trait Bounds Complexity

HRTBs (`for<'a> Fn(&'a T) -> &'a U`) introduce quantification over lifetimes that the compiler and users both struggle with. The Rustonomicon describes the syntax as "Intense." Common failure modes documented across dozens of Rust forum threads:

- Opaque return types (Futures) cannot be tied to HRTB lifetimes with standard `Fn` trait syntax, requiring trait objects or boxing.
- HRTB + async functions + lifetime inference frequently fail with non-obvious errors.
- Nested HRTB lifetimes with explicit bounds cause compiler failures (rust-lang/rust#95921).
[Representative forum: https://users.rust-lang.org/t/hrtb-lifetime-issue/89890]

### Pin and Self-Referential Structs

The `Pin<P>` type is required for async futures and self-referential structs. The well-known "Pin and suffering" tutorial (fasterthanlime.me) demonstrates the complexity:

- Once a value is pinned, it can never be used unpinned again unless it implements `Unpin`
- Even simple field access (`&mut self.field`) is forbidden after pinning a struct containing any `!Unpin` field
- The only solution is `unsafe` blocks with `Pin::new_unchecked()` and `get_unchecked_mut()`
- Violation of pinning invariants produces undefined behavior silently — the compiler cannot detect the swap of two pinned futures

Quote from the article: "In this case, we can just pin our `SlowRead` before reading from it. But remember — once we use it pinned, we can never use it _unpinned_ again...dangerous territory, because we have to uphold some guarantees ourselves." [https://fasterthanli.me/articles/pin-and-suffering]

The Rust forum thread "it's everyone's favorite recurring topic: self-referential structs" reflects that developers regularly hit this wall. The canonical advice — "avoid self-referential structs" — appears in multiple official learning resources, acknowledging the type system cannot express them ergonomically. [https://users.rust-lang.org/t/its-everyones-favorite-recurring-topic-self-referential-structs/91105]

---

## 6. Error Type Ecosystem Fragmentation

### Multiple Competing Libraries with No Standard

The Rust error handling ecosystem has no official recommendation and multiple competing crates that are not interoperable:

- **anyhow**: Opaque error type for applications; uses trait objects
- **thiserror**: Procedural macro for deriving `Error` implementations
- **eyre**: Fork of anyhow with customizable error reports
- **snafu**: Alternative derive-based approach with different philosophy
- **error-chain** (historic, now abandoned)
- **failure** (historic, abandoned)

The "emerging consensus" of "use `thiserror` for libraries, use `anyhow` for applications" has been critiqued as a mischaracterization. From the unwoundstack.com analysis:

> "The reasons for using anyhow vs thiserror aren't really based on if it's a library or an application, it's actually about whether or not you need to handle errors or report them."

This distinction causes developers to regularly refactor: "errors they were just propagating turned into errors they should be handling. Over time, they found themselves constantly refactoring such errors from anyhow to own types." [https://www.unwoundstack.com/blog/rust-error-handling.html]

### Compilation Time Cost of Error Libraries

The `thiserror` procedural macro introduces measurable compile time overhead. From measurements documented by BurntSushi (ripgrep author) and cited in multiple sources:

- With `thiserror`: **5 seconds (debug)** / **7.5 seconds (release)** added to compile times
- Without (hand-coded): **0.37 seconds (debug)** / **0.39 seconds (release)**
- Ratio: approximately **13–20× slower** compile times when using thiserror vs. hand-coding

Similarly, removing `snafu` from one project yielded a "21% speed-up in compilation times." [Source: https://www.unwoundstack.com/blog/rust-error-handling.html]

### The "Artisanal Error" Problem

A key criticism: elaborate error enumerations with dozens of variants are common in Rust libraries, but callers typically only respond to errors in three ways: treating as contract violations, retryable failures, or unrecoverable. Adding variants to a public error enum is a **breaking API change**, meaning over-specified error types actively harm library evolution.

GreptimeDB's engineering blog (May 2024) concluded that "there are tons of opinionated articles or libraries promoting their best practices, leading to an epic debate that never ends." They ultimately chose `snafu` after finding neither `thiserror` nor `anyhow` handled their multi-crate project's needs. [https://greptime.com/blogs/2024-05-07-error-rust]

---

## 7. GATs (Generic Associated Types) Complexity

### Background: Six-Year Wait, Incomplete Stabilization

GATs (Generic Associated Types) were stabilized in Rust 1.65 (November 3, 2022), more than **6.5 years** after the original RFC was opened. The official stabilization announcement acknowledged known bugs and limitations at time of release. [https://blog.rust-lang.org/2022/10/28/gats-stabilization/]

### Documented Limitations at Stabilization

The Rust types team published a HackMD document ("GATs stabilization concerns") acknowledging these limitations:

**1. Implied `'static` requirement from Higher-Ranked Trait Bounds**
When writing `for<'a> I::Item<'a>: Trait` bounds, the compiler incorrectly requires a `'static` lifetime, preventing valid uses like lending iterators over borrowed data. Described as "the most limiting, annoying, and tough to figure out" limitation.

**2. Traits with GATs are not object safe**
Trait objects (`dyn Trait`) cannot be created from traits with GATs. The design for this was deferred.

**3. Borrow checker limitations**
- Closures used with GAT-based methods produce spurious borrow checker errors
- Implementations using borrowed values fail with "cannot borrow as mutable more than once" errors
- These are scheduled for resolution via Polonius — which itself remained unstable as of 2025.

**4. Mandatory where clauses**
Provable bounds from method signatures must be explicitly written on the GAT itself, creating verbose boilerplate.

[Source: https://hackmd.io/@rust-types-team/SkXrAXlwq]

### Complexity Cost

From the Rust annual survey data cited in the GATs stabilization post: **33% of Rust users identify language complexity as their primary concern**.

The stabilization notes: "GATs nearly always increase complexity by introducing new syntax and new semantics to the type system. More critically, GATs' complexity is not a 'zero-cost abstraction' — GATs will primarily be used by library authors as part of the API, thus programmers will not get a choice to avoid them." [https://blog.rust-lang.org/2022/10/28/gats-stabilization.html]

Concerns raised before stabilization: "very few GATs use cases had been proved out, with no known cases that had been implemented and demonstrated to be significantly useful." Critics argued this represented a departure from Rust's design philosophy toward higher-kinded type abstractions "that are not the Rust way." [https://hackmd.io/@rust-types-team/SkXrAXlwq]

---

## 8. Lack of Formal Specification

### Current State

Rust has no ISO, IEC, or ECMA standard. The Rust Reference (https://doc.rust-lang.org/reference/) is explicitly incomplete — the aliasing rules for unsafe code remain undocumented/under development. Developers writing unsafe code must consult multiple sources or rely on observed compiler behavior rather than language guarantees.

The Rust Project's official position, stated by Mara Bos ("Do we need a 'Rust Standard'?") is that delegating to a standards body "would mean giving up control with little benefit." [https://blog.m-ou.se/rust-standard/]

### Why This Is a Problem: "Rust Needs an Official Specification"

A 2024 blog post from Tweede Golf ("Rust needs an official specification") identified concrete harms:

- **EAL5 certification is blocked:** Safety-critical systems requiring EAL5 (Common Criteria Evaluation Assurance Level 5) certification require an explicit implementation standard. "Rust cannot be used to achieve EAL5" without one.
- **Unsafe code correctness:** "If you have to walk a tightrope without a safety net, you had better know where to attach the rope." Unsafe code authors need definitive rules, not inferences from compiler behavior.
- **Alternative compiler support:** Without a specification, building competing implementations like `gccrs` risks language fragmentation.
- **The Ferrocene gap:** Ferrocene provides a working specification, but "does not have official status" as a Rust Project document. As a commercial product from Ferrous Systems, it is "not officially promulgated by the Rust Project."
[Source: https://tweedegolf.nl/en/blog/140/rust-needs-an-official-specification]

An LWN.net discussion (December 2023) captured the community debate: "They created a specification for Ferrocene because Rust does not *yet* have a language specification." The Ferrocene specification is descriptive rather than prescriptive — it must follow what the Rust compiler does, and cannot deviate without going through the RFC process. [https://news.ycombinator.com/item?id=38688595]

### Ferrocene and the Safety-Critical Gap

Ferrocene (a Ferrous Systems + AdaCore collaboration) produced the Ferrocene Language Specification (FLS) to qualify the Rust compiler for automotive (ISO 26262), industrial (IEC 61508), and other safety-critical uses. The FLS was donated to the Rust Project in 2023 and is being adopted as the basis for an official specification.

However, the January 2026 Rust Blog post "What does it take to ship Rust in safety-critical?" documents that significant gaps remain:

- **No MATLAB/Simulink code generation for Rust**
- **No OSEK or AUTOSAR Classic-compatible RTOS in Rust**
- **Async Rust has no qualification story** for high-criticality ISO 26262 components
- **Compiler version pinning conflicts** with ecosystem expectations, creating "very time-consuming" maintenance work
- **Essential math functions** (e.g., trigonometry) exist only in `std` and third-party crates, not in `core`, blocking `no_std` safety-critical work

[Source: https://blog.rust-lang.org/2026/01/14/what-does-it-take-to-ship-rust-in-safety-critical/]

### Vision for an Official Spec

The Inside Rust blog post "Our Vision for the Rust Specification" (November 2023) acknowledged that a specification had been approved via RFC (July 2023) and work was beginning. This represents official recognition that the absence of a spec was a gap requiring remediation. [https://blog.rust-lang.org/inside-rust/2023/11/15/spec-vision.html]

---

## Summary Table of Key Metrics

| Topic | Key Metric | Source |
|---|---|---|
| Async: developers who stopped using Rust citing compile times | 45% | Rust Compiler Performance Survey 2025 |
| Unsafe code: crates using `unsafe` directly | 19.11% | Rust Foundation 2024 |
| Unsafe code: crates transitively calling `unsafe` code | 34.35% | Rust Foundation 2024 |
| Soundness bugs found by RUDRA in one scan | 264 | SOSP 2021 paper |
| RustSec advisories filed by RUDRA | 112 | SOSP 2021 paper |
| Standard library soundness issues (3-year period) | 57 | SandCell arxiv 2025 |
| Worry Rust will become too complex (2024 survey) | 45.2% | State of Rust 2024 |
| Incremental rebuild wait > 10 seconds | 55% | Rust Compiler Perf Survey 2025 |
| GATs stabilization delay from RFC to stable | 6.5 years | Rust Blog 2022 |
| Open RFCs >1 year old (at time of ncameron post) | 54 | ncameron.org |
| Rust compile time growth vs. C++ (32× file copies) | 6.9× vs. 2.5× | Shape of Code 2023 |

---

## References

- [BITBASHING-ASYNC] "Async Rust Is A Bad Language." bitbashing.io. https://bitbashing.io/async-rust.html
- [CORRODE-ASYNC] "The State of Async Rust: Runtimes." corrode.dev. https://corrode.dev/blog/async/
- [MORESTINA-COLORED] "Rust async is colored, and that's not a big deal." morestina.net. https://morestina.net/1686/rust-async-is-colored
- [SEAQL-RAINBOW] "The rainbow bridge between sync and async Rust." SeaQL. 2024-05-20. https://www.sea-ql.org/blog/2024-05-20-async-rainbow-bridge/
- [ASYNC-BOOK-ECOSYSTEM] "The Async Ecosystem." Asynchronous Programming in Rust. https://rust-lang.github.io/async-book/08_ecosystem/00_chapter.html
- [RFC-2916] "async runtime into std." rust-lang/rfcs#2916. https://github.com/rust-lang/rfcs/issues/2916
- [BABYSTEPS-ASYNC-2024] "What I'd like to see for Async Rust in 2024." Niko Matsakis. 2024-01-03. https://smallcultfollowing.com/babysteps/blog/2024/01/03/async-rust-2024/
- [TECH-CHAMPION-ASYNC] "The 'One True Runtime' Friction in Async Rust Development." tech-champion.com. https://tech-champion.com/general/the-one-true-runtime-friction-in-async-rust-development/
- [ASYNC-STD-DEPRECATION] "Async-std deprecation." Rust Internals. https://internals.rust-lang.org/t/async-std-deprecation/23395
- [KOBZOL-COMPILE-WHY] "Why doesn't Rust care more about compiler performance?" Jakub Beranek. 2025-06-09. https://kobzol.github.io/rust/rustc/2025/06/09/why-doesnt-rust-care-more-about-compiler-performance.html
- [KOBZOL-BOTTLENECK] "What part of Rust compilation is the bottleneck?" Jakub Beranek. 2024-03-15. https://kobzol.github.io/rust/rustc/2024/03/15/rustc-what-takes-so-long.html
- [SHAPE-OF-CODE-CPP] "A comparison of C++ and Rust compiler performance." Shape of Code. 2023-01-29. https://shape-of-code.com/2023/01/29/a-comparison-of-c-and-rust-compiler-performance/
- [RUSTBLOG-COMPILE-SURVEY-2025] "Rust compiler performance survey 2025 results." Rust Blog. 2025-09-10. https://blog.rust-lang.org/2025/09/10/rust-compiler-performance-survey-2025-results/
- [RUSTBLOG-SURVEY-2023] "2023 Annual Rust Survey Results." Rust Blog. 2024-02-19. https://blog.rust-lang.org/2024/02/19/2023-Rust-Annual-Survey-2023-results/
- [RUSTBLOG-SURVEY-2024] "2024 State of Rust Survey Results." Rust Blog. 2025-02-13. https://blog.rust-lang.org/2025/02/13/2024-State-Of-Rust-Survey-results/
- [REGISTER-MOD-2021] "Entire Rust moderation team resigns." The Register. 2021-11-23. https://www.theregister.com/2021/11/23/rust_moderation_team_quits/
- [NEWSTACK-MOD-2021] "Rust Mod Team Resigns in Protest of 'Unaccountable' Core Team." The New Stack. https://thenewstack.io/rust-mod-team-resigns-in-protest-of-unaccountable-core-team/
- [MOD-PR-671] "mod team resignation." github.com/rust-lang/team/pull/671. https://github.com/rust-lang/team/pull/671
- [REGISTER-CORE-2022] "Trio of Rust Core Team members hit the road." The Register. 2022-02-01. https://www.theregister.com/2022/02/01/rust_core_team_departures/
- [THEPHD-RUSTCONF] "I Am No Longer Speaking at RustConf 2023." ThePhD.dev. 2023-05-26. https://thephd.dev/i-am-no-longer-speaking-at-rustconf-2023
- [RUSTBLOG-RUSTCONF] "On the RustConf keynote." Rust Blog. 2023-05-29. https://blog.rust-lang.org/2023/05/29/RustConf/
- [LWN-RUSTCONF] "A post on the RustConf keynote fiasco." LWN.net. 2023-05-30. https://lwn.net/Articles/933198/
- [DEVCLASS-GOVERNANCE] "More Rust ructions as project team confesses failure of 'leadership chat'." DevClass. 2023-05-31. https://devclass.com/2023/05/31/more-rust-ructions-as-project-team-confesses-failure-of-leadership-chat/
- [SLASHDOT-CONSTITUTION] "Rust Project Reveals New 'Constitution' in Wake of Crisis." Slashdot. 2023-03-05. https://developers.slashdot.org/story/23/03/05/018235/rust-project-reveals-new-constitution-in-wake-of-crisis
- [LWN-RFC3392] "The Rust Leadership Council." LWN.net. https://lwn.net/Articles/935354/
- [NCAMERON-RFCS] "We need to talk about RFCs." ncameron.org. https://www.ncameron.org/blog/the-problem-with-rfcs/
- [RUSTFOUNDATION-UNSAFE-WILD] "Unsafe Rust in the Wild: Notes on the Current State of Unsafe Rust." Rust Foundation. 2024. https://rustfoundation.org/media/unsafe-rust-in-the-wild-notes-on-the-current-state-of-unsafe-rust/
- [RUDRA-PAPER] "Rudra: Finding Memory Safety Bugs in Rust at the Ecosystem Scale." SOSP 2021. https://dl.acm.org/doi/10.1145/3477132.3483570
- [RUSTSEC-UNSOUND] "Advisories with keyword 'unsound'." RustSec Advisory Database. https://rustsec.org/keywords/unsound.html
- [RUSTSEC-TOKIO-2023] "RUSTSEC-2023-0005: tokio::io::ReadHalf unsplit is Unsound." https://rustsec.org/advisories/RUSTSEC-2023-0005.html
- [RUSTSEC-OUROBOROS] "RUSTSEC-2023-0042: Ouroboros is Unsound." https://rustsec.org/advisories/RUSTSEC-2023-0042.html
- [RUSTSEC-SELF-CELL] "RUSTSEC-2023-0070: self_cell: Insufficient covariance check." https://rustsec.org/advisories/RUSTSEC-2023-0070
- [SANDCELL-ARXIV] "SandCell: Sandboxing Rust Beyond Unsafe Code." arXiv:2509.24032. https://arxiv.org/html/2509.24032v1
- [NOTGULL-UNSAFE] "The rabbit hole of unsafe Rust bugs." notgull.net. https://notgull.net/cautionary-unsafe-tale/
- [VIRALINSTRUCTION-BORROW] "The borrowchecker is what I like the least about Rust." viralinstruction.com. https://viralinstruction.com/posts/borrowchecker/
- [POLONIUS-GOALS-2025H2] "Stabilizable Polonius support on nightly." Rust Project Goals 2025h2. https://rust-lang.github.io/rust-project-goals/2025h2/polonius.html
- [EURORUST-POLONIUS] "The First Six Years in the Development of Polonius." EuroRust 2024. https://eurorust.eu/2024/talks/the-first-six-years-in-the-development-of-polonius/
- [PIN-SUFFERING] "Pin and suffering." fasterthanlime.me. https://fasterthanli.me/articles/pin-and-suffering
- [SELF-REF-STRUCTS] "it's everyone's favorite recurring topic: self-referential structs." Rust Users Forum. https://users.rust-lang.org/t/its-everyones-favorite-recurring-topic-self-referential-structs/91105
- [GAT-STABILIZATION] "Generic associated types to be stable in Rust 1.65." Rust Blog. 2022-10-28. https://blog.rust-lang.org/2022/10/28/gats-stabilization/
- [GAT-CONCERNS] "GATs stabilization concerns." Rust Types Team. HackMD. https://hackmd.io/@rust-types-team/SkXrAXlwq
- [UNWOUNDSTACK-ERRORS] "Rust Error Handling." unwoundstack.com. https://www.unwoundstack.com/blog/rust-error-handling.html
- [GREPTIME-ERRORS] "Error Handling for Large Rust Projects." GreptimeDB. 2024-05-07. https://greptime.com/blogs/2024-05-07-error-rust
- [TWEEDE-SPEC] "Rust needs an official specification." Tweede Golf. https://tweedegolf.nl/en/blog/140/rust-needs-an-official-specification
- [MARA-STANDARD] "Do we need a 'Rust Standard'?" Mara Bos. https://blog.m-ou.se/rust-standard/
- [SPEC-VISION] "Our Vision for the Rust Specification." Inside Rust Blog. 2023-11-15. https://blog.rust-lang.org/inside-rust/2023/11/15/spec-vision.html
- [SAFETY-CRITICAL-2026] "What does it take to ship Rust in safety-critical?" Rust Blog. 2026-01-14. https://blog.rust-lang.org/2026/01/14/what-does-it-take-to-ship-rust-in-safety-critical/
- [HN-FERROCENE] "They created a specification for Ferrocene because Rust does not yet have a language specification." Hacker News. https://news.ycombinator.com/item?id=38688595
